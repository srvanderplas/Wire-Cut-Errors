<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.489">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Susan Vanderplas">

<title>Lit Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="lit_files/libs/clipboard/clipboard.min.js"></script>
<script src="lit_files/libs/quarto-html/quarto.js"></script>
<script src="lit_files/libs/quarto-html/popper.min.js"></script>
<script src="lit_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="lit_files/libs/quarto-html/anchor.min.js"></script>
<link href="lit_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lit_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lit_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="lit_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="lit_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lit Review</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Susan Vanderplas </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="screwdriverschisels" class="level2">
<h2 class="anchored" data-anchor-id="screwdriverschisels">Screwdrivers/Chisels</h2>
<ul>
<li><p><span class="citation" data-cites="garcia2017">Garcia, Pieterman, and Baiker (<a href="#ref-garcia2017" role="doc-biblioref">2017</a>)</span></p>
<ul>
<li><p>Overall Rating: üåà</p></li>
<li><p>Parameter definitions:<br>
<img src="fig/Garcia_2017_fig1.png" class="img-fluid"></p>
<ul>
<li>Angle of attack <span class="math inline">\(\alpha\)</span> vs.&nbsp;axial rotation <span class="math inline">\(\gamma\)</span></li>
</ul></li>
<li><p>Experimental Design:</p>
<ul>
<li><p>5 Sencys CR-V 10x200mm electrician‚Äôs chisels (tip = 9.35x1.85mm)</p></li>
<li><p><span class="math inline">\(\alpha = 0\)</span></p></li>
<li><p><span class="math inline">\(\gamma = \{0, 15, 30, 45, 60, 75\}^\circ\)</span></p></li>
<li><p>2 repeat observations</p></li>
<li><p>marks were cast, scanned with 20x objective magnification, 800nm vertical resolution, <span class="math inline">\(2\mu m\)</span> lateral resolution, ~10x0.7mm scanning areas, 32 bit precision.</p></li>
</ul></li>
<li><p>‚ÄúTool marks have to be created in a consistent manner that reduces factors that might induce variation in or between marks. Most of these factors are caused by the manual creation of marks‚Äù (pg 206)</p>
<ul>
<li><p>does this mean that manual creation of marks is less reliable?</p></li>
<li><p>Can toolmarks hold up to practical situations where both the examiner and the accused would have made manual marks?</p></li>
</ul></li>
<li><p>Results:</p>
<ul>
<li><p>Based on a preliminary investigation it was observed that the tool mark width (y-axis) compressed with increasing axial rotation. Based on the widths of the experimental marks the average deviation from the theoretical compression factors (1.000, 0.966, 0.866, 0.707, 0.500 and, 0.258) was calculated to be 0.792% <span class="math inline">\(\pm\)</span> 2.068</p></li>
<li><p>Without resizing, can only compare <span class="math inline">\(0^\circ\)</span> to <span class="math inline">\(15^\circ\)</span> within guidelines; with resampling and resizing, can compare across the <span class="math inline">\(\gamma\)</span> values chosen</p></li>
<li><p>Used wavelength filters to compare structural similarities:</p>
<ul>
<li>Wavelength ranges included were 1000‚Äì5, 1000‚Äì200, 200‚Äì100, 100‚Äì50, 50‚Äì25, 25‚Äì10 and 10‚Äì5 mm. This resulted in a similarity scores which depended solely on the comparison of structural details belonging to a certain wavelength range.</li>
</ul></li>
<li><p>Without resizing:<img src="fig/Garcia_2017_tab1.png" class="img-fluid"></p></li>
<li><p>With resizing:<br>
<img src="fig/Garcia_2017_tab2-3.png" class="img-fluid"></p></li>
<li><p><img src="fig/Garcia_2017_fig12.png" class="img-fluid"></p></li>
<li><p>Results somewhat dependent on noise removal threshold</p></li>
</ul></li>
</ul></li>
<li><p><span class="citation" data-cites="bachrach2010">Bachrach et al. (<a href="#ref-bachrach2010" role="doc-biblioref">2010</a>)</span></p></li>
<li><p><span class="citation" data-cites="yang2019">Yang et al. (<a href="#ref-yang2019" role="doc-biblioref">2019</a>)</span></p></li>
<li><p><span class="citation" data-cites="petraco2012">Petraco et al. (<a href="#ref-petraco2012" role="doc-biblioref">2012</a>)</span></p></li>
</ul>
</section>
<section id="wire-cutters" class="level2">
<h2 class="anchored" data-anchor-id="wire-cutters">Wire Cutters</h2>
<ul>
<li><p><span class="citation" data-cites="heikkinen2014">Heikkinen et al. (<a href="#ref-heikkinen2014" role="doc-biblioref">2014</a>)</span></p>
<ul>
<li><p>Overall rating: üí©üí©</p></li>
<li><p>Introduction</p>
<ul>
<li><p>When diagonal cutters are used to cut wires, they leave marks that were created by a part of the blade on the cut surface (4,5). Small (less than mm2) partial marks may not allow matching the tool to a mark using standard comparison microscopy (e.g., Leica FSC used in this study [8]) because there may be too few recognizable features to declare a match or nonmatch with sufficient certainty <span class="citation" data-cites="nichols2">(<a href="#ref-nichols2" role="doc-biblioref">Nichols 2003</a>)</span>. 3D imaging provides a potential way to address this issue: It allows seeing small features and potentially recognizing a match from a small partial toolmark. With precise 3D imaging, fewer striations are needed to declare that two marks were made using the same tool (Table 1). <span class="citation" data-cites="nichols2">(<a href="#ref-nichols2" role="doc-biblioref">Nichols 2003</a>)</span></p>
<ul>
<li><p>Quote from <span class="citation" data-cites="nichols2">Nichols (<a href="#ref-nichols2" role="doc-biblioref">2003</a>)</span>:</p>
<blockquote class="blockquote">
<p>In three dimensional toolmarks when at least two different groups of at least three consecutive matching striae appear in the same relative position, or one group of six consecutive matching striae are in agreement in an evidence toolmark compared to a test toolmark. In two dimensional toolmarks when at least two groups of at least five consecutive matching striae appear in the same relative position, or one group of eight consecutive matching striae are in agreement in an evidence toolmark. For these criteria to apply, however, the possibility of sub-class characteristics must be ruled out.</p>
</blockquote></li>
</ul></li>
</ul></li>
<li><p>Design:</p>
<ul>
<li><p>2mm wires cut with 2 different diagonal cutters from the same production batch and what seems to be a 3rd cutter that wasn‚Äôt from the batch? (description NOT clear)</p></li>
<li><p>blades marked to ensure cuts were with same part of the blade (5 cutting positions, but only 3 )</p></li>
<li><p>3D optical imaging</p></li>
</ul></li>
<li><p>Results</p>
<ul>
<li><p>74/80 profiles identified using CMS (even using images taken w/ different 3D scanners)</p></li>
<li><p>Wear is visible after 500 cuts but can still be assessed using CMS (and from Fig 7, probably using crosscorr as well)</p></li>
<li><p>Different blades have different characteristics</p></li>
<li><p>different parts of the same blade have different characteristics</p></li>
<li><p>3D imaging provides more details relative to 2D imaging</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="bolt-cutters" class="level2">
<h2 class="anchored" data-anchor-id="bolt-cutters">Bolt Cutters</h2>
<ul>
<li><p><span class="citation" data-cites="butcher1975">Butcher and Pugh (<a href="#ref-butcher1975" role="doc-biblioref">1975</a>)</span></p></li>
<li><p><span class="citation" data-cites="yang2019">Yang et al. (<a href="#ref-yang2019" role="doc-biblioref">2019</a>)</span></p></li>
</ul>
</section>
<section id="pliers" class="level2">
<h2 class="anchored" data-anchor-id="pliers">Pliers</h2>
<ul>
<li><p><span class="citation" data-cites="bachrach2010">Bachrach et al. (<a href="#ref-bachrach2010" role="doc-biblioref">2010</a>)</span></p></li>
<li><p><span class="citation" data-cites="kassamakov2010">Kassamakov et al. (<a href="#ref-kassamakov2010" role="doc-biblioref">2010</a>)</span></p></li>
<li><p><span class="citation" data-cites="yang2019">Yang et al. (<a href="#ref-yang2019" role="doc-biblioref">2019</a>)</span></p></li>
</ul>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bachrach2010" class="csl-entry" role="listitem">
Bachrach, Benjamin, Anurag Jain, Sung Jung, and Robert D. Koons. 2010. <span>‚ÄúA Statistical Validation of the Individuality and Repeatability of Striated Tool Marks: Screwdrivers and Tongue and Groove Pliers*.‚Äù</span> <em>Journal of Forensic Sciences</em> 55 (2): 348‚Äì57. <a href="https://doi.org/10.1111/j.1556-4029.2009.01221.x">https://doi.org/10.1111/j.1556-4029.2009.01221.x</a>.
</div>
<div id="ref-butcher1975" class="csl-entry" role="listitem">
Butcher, Shirley J., and P. D. Pugh. 1975. <span>‚ÄúA Study of Marks Made by Bolt Cutters.‚Äù</span> <em>Journal of the Forensic Science Society</em> 15 (2): 115‚Äì26. <a href="https://doi.org/10.1016/S0015-7368(75)70965-9">https://doi.org/10.1016/S0015-7368(75)70965-9</a>.
</div>
<div id="ref-garcia2017" class="csl-entry" role="listitem">
Garcia, Derrel Louis, Ren√© Pieterman, and Martin Baiker. 2017. <span>‚ÄúInfluence of the Axial Rotation Angle on Tool Mark Striations.‚Äù</span> <em>Forensic Science International</em> 279 (October): 203‚Äì18. <a href="https://doi.org/10.1016/j.forsciint.2017.08.021">https://doi.org/10.1016/j.forsciint.2017.08.021</a>.
</div>
<div id="ref-heikkinen2014" class="csl-entry" role="listitem">
Heikkinen, Ville Vili, Ivan Kassamakov, Claude Barbeau, Sami Lehto, Tapani Reinikainen, and Edward H√¶ggstr√∂m. 2014. <span>‚ÄúIdentifying Diagonal Cutter Marks on Thin Wires Using 3D Imaging.‚Äù</span> <em>Journal of Forensic Sciences</em> 59 (1): 112‚Äì16. <a href="https://doi.org/10.1111/1556-4029.12291">https://doi.org/10.1111/1556-4029.12291</a>.
</div>
<div id="ref-kassamakov2010" class="csl-entry" role="listitem">
Kassamakov, I., C. Barbeau, S. Lehto, P. Ahvenainen, T. Reinikainen, and E. H√¶ggstr√∂m. 2010. <span>‚ÄúThree-Dimensional Imaging, Visualization, and Display 2010 and Display Technologies and Applications for Defense, Security, and Avionics IV.‚Äù</span> In, 7690:269‚Äì77. SPIE. <a href="https://doi.org/10.1117/12.850046">https://doi.org/10.1117/12.850046</a>.
</div>
<div id="ref-nichols2" class="csl-entry" role="listitem">
Nichols, R. 2003. <span>‚ÄúFirearm and Toolmark Identification Criteria: A Review of the Literature, Part II.‚Äù</span> <em>Journal of Forensic Sciences</em> 48 (2): 318‚Äì27. <a href="https://doi.org/10.1520/JFS2002246">https://doi.org/10.1520/JFS2002246</a>.
</div>
<div id="ref-petraco2012" class="csl-entry" role="listitem">
Petraco, Nicholas D. K., Peter Shenkin, Jacqueline Speir, Peter Diaczuk, Peter A. Pizzola, Carol Gambino, and Nicholas Petraco. 2012. <span>‚ÄúAddressing the National Academy of Sciences<span>‚Äô</span> Challenge: A Method for Statistical Pattern Comparison of Striated Tool Marks.‚Äù</span> <em>Journal of Forensic Sciences</em> 57 (4): 900‚Äì911. <a href="https://doi.org/f34hfx">https://doi.org/f34hfx</a>.
</div>
<div id="ref-yang2019" class="csl-entry" role="listitem">
Yang, Min, Li Mou, Yi-Ming Fu, Yu Wang, and Jiang-feng Wang. 2019. <span>‚ÄúQuantitative Statistics and Identification of Tool-Marks.‚Äù</span> <em>Journal of Forensic Sciences</em> 64 (5): 1324‚Äì34. <a href="https://doi.org/10.1111/1556-4029.14040">https://doi.org/10.1111/1556-4029.14040</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>